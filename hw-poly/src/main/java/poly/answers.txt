## CSE 331 hw-poly Questions
## Part 0
###########################################################################

1. Multiplication Pseudocode
    r = p * q:
        set r = 0
        foreach term, t_p, in p:
            foreach term, t_q, in q:
                set t_pq to be the multiplication of t_p and t_q
                if any term, t_r, in r has the same degree as t_pq
                    then replace t_r by the sum of t_r and t_pq
                    else insert t_pq to r as a new term


2. Division Pseudocode
    q = u / v:
        set q = 0
        set r = u by making a term-by-term copy of all terms in u to r
        while (the highest degree of r) is greater than or equal to (the highest degree of v)
            set c = coefficient of the highest degree term of r / coefficient of the highest degree term of v
            set d = highest degree of r - highest degree of v
            adding a term with coefficient c and degree d to q
            subtracting (v multiplied by the term with coefficient c and degree d) from r


3. Division Example: (x3+x-1) / (x+1) = x2-x+2
    u = (x^3+x-1)
    v = (x+1)
    q = 0
    r = u = (x^3+x-1)
    the highest degree of v(x+1) is 1

    Iteration 1: u=(x^3+x-1), v=(x+1), q=0, r=(x^3+x-1), highest degree of r=3, highest degree of v=1
    [while the highest degree of r is greater than or equal to the highest degree of v] [YES]
        [set c = coefficient of the highest degree term of r / coefficient of the highest degree term of v]
        c = 1 / 1 = 1
        [set d = highest degree of r - highest degree of v]
        d = 3 - 1 = 2
        [adding a term with coefficient c and degree d to q]
        q = q + 1*x^2 = x^2
        [subtracting (v multiplied by the term with coefficient c and degree d) from r]
        r = r - v*c*x^d = (x^3+x-1) - (x+1)*(1)*(x^2) = (x^3+x-1) - (x^3+x^2) = -x^2+x-1

    Iteration 2: u=(x^3+x-1), v=(x+1), q=(x^2), r=(-x^2+x-1), highest degree of r=2, highest degree of v=1
    [while the highest degree of r is greater than or equal to the highest degree of v] [YES]
        [set c = coefficient of the highest degree term of r / coefficient of the highest degree term of v]
        c = -1 / 1 = -1
        [set d = highest degree of r - highest degree of v]
        d = 2 - 1 = 1
        [adding a term with coefficient c and degree d to q]
        q = q + (-1)*x^1 = x^2-x
        [subtracting (v multiplied by the term with coefficient c and degree d) from r]
        r = r - v*c*x^d = (-x^2+x-1) - (x+1)*(-1)*(x^1) = (-x^2+x-1) - (-x^2-x) = 2x-1

    Iteration 3: u=(x^3+x-1), v=(x+1), q=(x^2-x), r=(2x-1), highest degree of r = 1, highest degree of v = 1
    [while the highest degree of r is greater than or equal to the highest degree of v] [YES]
        [set c = coefficient of the highest degree term of r / coefficient of the highest degree term of v]
        c = 2 / 1 = 2
        [set d = highest degree of r - highest degree of v]
        d = 1 - 1 = 0
        [adding a term with coefficient c and degree d to q]
        q = q + (2)*x^0 = (x^2 - x) + 2
        [subtracting (v multiplied by the term with coefficient c and degree d) from r]
        r = r - v*c*x^d = (-x^2+x-1) - (x+1)*(2)*(x^0) = (2x-1) - (2x+2) = -3

    u=(x^3+x-1), v=(x+1), q=(x^2-x+2), r=-3, highest degree of r = 0, highest degree of v = 1    =>
    [while the highest degree of r is greater than or equal to the highest degree of v] [NO]
    Here we have q = x^2-x+2, and we are DONE!
    =>  (x3+x-1) / (x+1) = x2-x+2


## Part 1
###########################################################################

1. Weakened Rep Invariant
    The constructor RatNum(int n, int d) needs to remove calling gcd() method
    and the following two lines of code to meet the new rep invariant. This
    change is more efficient as it bypass the procedure of calling gcd() for
    this constructor, making the execution to be faster and the code shorter.
    However, it will then require those methods that rely on using reduced form
    to do these extra transformation, which will slow down the execution.

    The method checkRep() needs to remove the if check as the rep invariant
    changes. This makes the code more clear and makes the method to run faster
    as it now requires less condition check.

    The methods hashCode() and equals(Object obj) need to add calling gcd()
    method to so that they could treat numbers that are in reduced form and
    numbers that are not in reduced form at same standard so that both methods
    could return the correct results. This change is less efficient as it needs
    extra execution of gcd(), making the overall execution time to be longer.

    The method toString() needs to add calling gcd() method for reduction to meet
    the new rep invariant. This change is less efficient as it requires extra
    execution, making the overall execution time to be longer.


2. Alternate add, sub, mul, div
    The changes fail to meet the specifications of the methods because the specs
    of these methods don't have @sepc.modifies clause, meaning it should not be
    modified by the methods. In case of assign new values via the implementation
    in the question, we are actually modify things and it violates the spec.

    The changes fail to meet the specifications of the RatNum class because the
    general spec of the class says that RatNum represents an immutable rational
    number, whereas the given changes will mutate numbers and therefore violate
    the spec.


3. Constructor checkReps
    The reason why calling checkRep only at the end of the constructors is already
    sufficient is that the denom is set to 1 in constructor RatNum(int n), which
    won't violate the rep invariant. And denom is set to -d in case of being negative
    at first in the constructor RatNum(int n, int d), and this won't violate the rep
    invariant. Additionally, RatNum class represents immutable rational numbers, so
    these instance variables are initialized at the beginning and declared as final,
    and no methods could even modify them except constructors. It prevents the fields
    to be modified and that's why calling checkRep only at the end of the constructors
    is sufficient to maintain the rep invariant.



## Part 2
###########################################################################

1. Calls to checkRep in RatTerm
    I include calls to the checkRep at the end of the constructor RatTerm(RatNum c, int e).
    The reason is that RatTerm is an immutable representation of a term in a single-variable
    polynomial expression, so the instance variables are initialized at the beginning and
    declared as final, and no method could modify them as all methods are returning new
    RatTerm object, leaving the original objects unmodified. Therefore, calling the checkRep
    at the end of this constructor is already sufficient to meet the rep invariant.


2. Weakened Rep Invariant
    The constructor RatTerm(RatNum c, int e) needs to remove the part that checks coeff to set expt.
    This change makes the code a bit clear and reduces the execution time.

    The method getExpt() needs to add a check if the coeff is zero and then return 0 accordingly.
    This change requires extra condition check, making code more complex and may takes longer execution
    time.

    The method add(RatTerm arg) needs to make changes to fit the case when both the input RatTerms are
    actually being 0, and the return RatTerm.ZERO accordingly. This change makes the code more complex
    and may takes longer execution time as it requires further condition check.

    The method toString() needs to add a call of method isZero() to check if the coeff is zero and
    then return 0 accordingly. This change makes the code a bit more complex and may takes longer
    execution time(very tiny) as it requires further condition check.

    The method equals(Object obj) needs to add a check for both this.coeff and obj are ZEROs, and
    return true in case of both are true. This change makes the code more complex and takes longer
    execution time(very tiny) as it requires further condition check.

    The method hashCode() needs to add a check for coeff is 0 and expt is not 0. And return 0 accordingly.
    This change requires extra check and makes the code more complex and takes longer exeuction time.

    The method checkRep() needs to remove the second assert. This change makes the code more efficient,
    and reduces the execution time of the method as it requires less assertion check.


3. Alternate Rep Invariant
    The constructor RatTerm(RatNum c, int e) needs to change to fit the condition when passed parameter
    being NaN. In case of passing in NaN, the expt will then be set to 0 to handle this special case.
    This change does require a bit more code for dealing with extra case and therefore being more complex.


4. Preferred Invariants
    I prefer coeff.equals(RatNum.ZERO) => expt = 0. The reason is that this rep invariants is much stronger
    than the other one. It covers more edge cases and there is no need to consider these cases when doing
    the arithmetic calculations.



## Part 3
###########################################################################

1. Calls to checkRep in RatPoly
    I include calls to checkRep at the end of four constructors. The reason is that RatPoly
    represents an immutable single-variate polynomial expression. The instance variable terms
    is initialized at the beginning and declared as final, and no method could modify it as
    all methods are returning new object, leaving the original object unmodified. Therefore,
    calling the checkRep at the end of the constructors is already sufficient to meet the
    rep invariant.


2. Alternate Representation
    In case of using two separate lists to keep track of the RatNum coefficients and int exponents
    of each term, it has the advantage of accessing coefficient and exponent for typical term to be
    to be actually the same, maybe more intuitive. However, it has the disadvantage when adding/removing
    term into a RatPoly as we now need to modify two lists and this is prone to make mistakes.


