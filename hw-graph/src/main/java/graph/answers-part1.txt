## CSE 331 hw-graph Part 1 Questions

## Section 1
###########################################################################

1. Write an AF and RI for IntQueue1 and IntQueue2.

    ### IntQueue1

    Abstraction Function:
        AF(this) = Queue<Integer> entries such that
            queue = entries = [] if there are no elements in entries
            queue = entries = [n1, n2, ..., n_k] that k is the number of elements in entries (entries.size())



    Representation Invariant:
        entries != null
        && entries.get(i) != null when 0 <= i < entries.size()



    ### IntQueue2

    Abstraction Function:
        AF(this) = Queue<Integer> such that
            entries = [n1, n2, ..., n_k], front = i, size = n
            queue = [] if size = 0
            queue = [a_(i+1), ..., a_(i+n)] if front+size <= entries.length
            queue = [a_(i+1), ..., a_k, a1, ..., a_(k-i)] if front+size > entries.length



    Representation Invariant:
        entries != null
        && size >= 0
        && size <= entries.length
        && front >= 0
        && front < entries.length



2. Group the snapshots of IntQueue2's internal state into groups that have the same abstract state.
    queue a = [1, 2]
    queue b = [2, 3, 4]
    queue c = [1, 2, 3]
    queue d = [1, 2]
    queue e = [1, 2, 3, 4]
    queue f = [1, 2, 3]
    queue g = [1, 2]
    queue h = [2, 3, 4]

    Upon the write-up above,
    queue a, d, g are identical = [1, 2].
    queue c, f are identical = [1, 2, 3].
    queue b, h are identical = [2, 3, 4].
    queue e is unique here = [1, 2, 3, 4].



3. For each signature below, state and justify in 1-2 sentences (per part) whether the method or constructor
could possibly expose the representation, given the information available. Explain any assumptions you made.

    a. `public int solveEquations(int x, int y, int z)`
        This could never expose the representation because it takes parameters and returns the same
        primitive data type(int) instead of mutable objects. The client can not interact with it.


    b. `public String[] decode(boolean slowly)`
        This is possible to expose the representation because it returns an array of String here and
        array is a mutable type.


    c. `private Date myBirthday()`
        This is possible to expose the representation in the case of the Date type is mutable and the
        returned Data is not a copy of the original Date. Otherwise, there will be no representation
        expose.


    d. `public String toString()`
        This could never expose the representation because the return type String is immutable.


    e. `public Iterator<Integer> elements()`
        This is possible to expose the representation in the case of the returned Iterator refers
        to the original collection and it has the remove method that client could use to remove
        elements.


    f. `public Deck(List<Card> cards)`
        This is possible to expose the representation in the case of Deck is mutable and it's not
        a copy of the original Deck as client could make modification to it.



## Section 2
###########################################################################

Briefly explain why you included the operations you did and why you feel they are a sufficient
interface to a graph. If your design includes multiple classes or interfaces, explain why you
included each one; if not, explain whether you considered additional classes and why you decided
not to include them.

I included two classes here, named MyEdge and MyGraph. I separate into these two classes for
better clarity, making things to be more organized.

MyEdge stores the destination node and the edge label of an edge.
It has the following constructors/methods:
    MyEdge(T dest, E edgeLabel)
        Creates a labeled edge.

    T getDest()
        Gets the destination node of this edge.

    E getEdgeLabel()
        Gets the edge label of this edge.

    String toString()
        Returns a string representation of this edge.

    boolean equals(Object obj)
        Standard equality operation.

    int hashCode()
        Standard hashCode function.

    int compareTo(MyEdge<T, E> obj)
        Compares this object with object obj for order.



MyGraph stores all the nodes and edges in the graph.
It has the following constructors/methods:
    MyGraph()
        Creates an empty directed graph.

    boolean addNode(T node)
        Add a new node to the graph in case of it is not present already.

    boolean addEdge(T source, T dest, E label)
        Add a new edge(source, destination, label) to the graph if
        both end nodes exist in the graph and the edge connecting
        two ends is not present in the graph yet.

    boolean removeNode(T node)
        Remove a node with its connecting edges from the graph.

    boolean removeEdge(T source, T dest, E label)
        Remove an edge from the graph.

    boolean containsNode(T node)
        Check if the node is in the graph.

    boolean containsEdge(T source, T dest, E label)
        Check if the edge is in the graph.

    boolean isConnected(T source, T dest)
        Check if two given nodes are connected by any edge.

    Set<T> adjacentNodes(T node)
        Get the nodes that are directly connected by a single edge to the given node.

    ArrayList<E> getEdges(T node)
        Get the edges that connects to the given node.

    Set<T> getAllNodes()
        Get all the nodes in the graph.

    ArrayList<E> getAllEdges()
        Get all the edges in the graph.

    int size()
        Gets the number of nodes in the graph.

    boolean isEmpty()
        Checks if the graph is empty or not.

    int hashCode()
        Standard hashCode function.

    boolean equals(Object obj)
        Standard equality operation.

    String toString()
        Returns a string representation of this directed graph.

With these constructor/methods, the graph could then add/remove nodes and edges, get specific
node(s)/edge(s) or get all nodes/edges in the graph, check if two given nodes are connected
directly, and get all edges from a typical node, etc. These methods allow the user/client to
obtain information about the graph.


## Section 3
###########################################################################

What was your testing strategy for this assignment? How do your script tests and JUnit tests
differ from each other (if they do), and why?



