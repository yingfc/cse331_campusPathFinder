## CSE 331 hw-graph Part 1 Questions

## Section 1
###########################################################################

1. Write an AF and RI for IntQueue1 and IntQueue2.

    ### IntQueue1

    Abstraction Function:
        AF(this) = Queue<Integer> such that
            queue = entries = [] if there are no elements in entries
            queue = entries = [n1, n2, ..., n_k] that k is the number of elements in entries (entries.size())



    Representation Invariant:
        entries != null
        && entries.get(i) != null (entries has no null elements) when 0 <= i < entries.size()



    ### IntQueue2

    Abstraction Function:
        AF(this) = Queue<Integer> such that
            entries = [n1, n2, ..., n_k], and front = i, size = n
            queue = [] when size = 0
            queue = [n_(i+1), ..., n_(i+n)] when front+size <= entries.length
            queue = [n_(i+1), ..., n_k, n1, ..., n_(k-i)] when front+size > entries.length



    Representation Invariant:
        entries != null
        && size >= 0
        && size <= entries.length
        && front >= 0
        && front < entries.length



2. Group the snapshots of IntQueue2's internal state into groups that have the same abstract state.
    queue a = [1, 2]
    queue b = [2, 3, 4]
    queue c = [1, 2, 3]
    queue d = [1, 2]
    queue e = [1, 2, 3, 4]
    queue f = [1, 2, 3]
    queue g = [1, 2]
    queue h = [2, 3, 4]

    Upon the write-up above,
    queue a, d, g are identical = [1, 2].
    queue c, f are identical = [1, 2, 3].
    queue b, h are identical = [2, 3, 4].
    queue e is unique here = [1, 2, 3, 4].



3. For each signature below, state and justify in 1-2 sentences (per part) whether the method or constructor
could possibly expose the representation, given the information available. Explain any assumptions you made.

    a. `public int solveEquations(int x, int y, int z)`
        This could never expose the representation because it takes parameters and returns the same
        primitive data type(int) instead of mutable objects. The client can not interact with it.


    b. `public String[] decode(boolean slowly)`
        This is possible to expose the representation because it returns an array of String here and
        array is a mutable type.


    c. `private Date myBirthday()`
        This is possible to expose the representation in the case of the Date type is mutable and the
        returned Data is not a copy of the original Date. Otherwise, there will be no representation
        expose.


    d. `public String toString()`
        This could never expose the representation because the return type String is immutable.


    e. `public Iterator<Integer> elements()`
        This is possible to expose the representation in the case of the returned Iterator refers
        to the original collection and it has the remove method that client could use to remove
        elements.


    f. `public Deck(List<Card> cards)`
        This is possible to expose the representation in the case of Deck is mutable and it's not
        a copy of the original Deck as client could make modification to it.



## Section 2
###########################################################################

Briefly explain why you included the operations you did and why you feel they are a sufficient
interface to a graph. If your design includes multiple classes or interfaces, explain why you
included each one; if not, explain whether you considered additional classes and why you decided
not to include them.

I included two classes here, an inner helper class named LabeledEdge and a main class named DirectedGraph.
I used the inner helper class for better clarity, making things to be more organized.

LabeledEdge inner class stores the destination node and the edge label of an edge.
It has the following constructor/methods:
    LabeledEdge(String dest, String edgeLabel)
        Creates a labeled edge.

    String getDest()
        Gets the destination node of this edge.

    String getEdgeLabel()
        Gets the edge label of this edge.

    String toString()
        Returns a string representation of this edge.

    boolean equals(Object obj)
        Standard equality operation.

    int hashCode()
        Standard hashCode function.



DirectedGraph class stores all the nodes and edges in the graph.
It has the following constructor/methods:
    DirectedGraph()
        Creates an empty directed graph.

    boolean addNode(String node)
        Add a new node to the graph in case of it is not present already.

    boolean addEdge(String source, String dest, String label)
        Add a new edge(source, destination, label) to the graph if
        both end nodes exist in the graph and the edge connecting
        two ends is not present in the graph yet.

    boolean containsNode(String node)
        Check if the node is in the graph.

    boolean containsEdge(String source, String dest, String label)
        Check if the edge is in the graph.

    boolean isConnected(String source, String dest)
        Check if two given nodes are connected by any edge.

    Set<String> childrenOf(String node)
        Get the children nodes of the given node.

    Set<LabeledEdge> getEdges(String node)
        Get the edges that connects to the given node.

    Set<String> getAllNodes()
        Get all the nodes in the graph.

    Set<LabeledEdge> getAllEdges()
        Get all the edges in the graph.

    int size()
        Gets the number of nodes in the graph.

    boolean isEmpty()
        Checks if the graph is empty or not.

    int hashCode()
        Standard hashCode function.

    boolean equals(Object obj)
        Standard equality operation.

    String toString()
        Returns a string representation of this directed graph.

With these constructor/methods, the graph could then add nodes/edges to construct the graph,
At the same time, methods like getting specific node(s)/edge(s) or getting all nodes/edges
in the graph, checking if two given nodes are connected directly, and getting children nodes/edges
from a typical node allow the user/client to obtain information about the graph.
containsNodes and containsEdges prevent having duplicated nodes/edges.


## Section 3
###########################################################################

What was your testing strategy for this assignment? How do your script tests and JUnit tests
differ from each other (if they do), and why?

I followed the hint of designing tests, using "0, 1, 2" case analysis.
For the script tests, I wrote a bunch of tests that can be checked using the given test script commands.
Specifically, I have cases of empty graph, graph with only one node, graph with one node and one
edge, graph with only two nodes, graph with two nodes and one edge, graph with two nodes and two edges
(both node pointing to each other and the version including self-loop),
the graph with two nodes and full edges(cover both nodes pointing to each other and self-loop),
and the graph with two nodes and multiple edges(including the repeated edges that share the same
starting node and destination node). Also, I included the case to check the adding order of nodes
and edges to test the order.
While for the JUnit tests, they cover the tests for that cannot be tested using the given test script
commands, such as tests on toString(), equals(), and hashCode() methods for the Edge class, and
tests on isConnected(), toString(), size(), isEmpty(), childrenOf(), etc for the Graph class. I made
cases for every public methods in the class. For the inner Edge class, I created 3 demo edges to test
its public methods. For the Graph class, I created 3 graph objects to cover cases of empty graph,
graph with only one node, and the graph with both nodes and edges.

Therefore, the script tests and the JUnit tests combine together to cover as many tests as possible,
The script tests mainly work on creating graph, adding node/edge, getting nodes/children nodes, these
that can be easily tested using the given commands. While the JUnit tests work on the rest of methods
such as checking connection, getting children nodes/edges, etc.

